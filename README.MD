# PayFlow

Sistema de gerenciamento de **assinaturas, faturamento e pagamentos simulados**, desenvolvido em **Java com Spring Boot**, com **processamento assÃ­ncrono via RabbitMQ**.

O projeto foi criado com foco em **boas prÃ¡ticas de arquitetura backend**, **ProgramaÃ§Ã£o Orientada a Objetos (POO)**, **mensageria**, **testes unitÃ¡rios** e **simulaÃ§Ã£o de um fluxo real de pagamento**, sendo ideal para estudo e portfÃ³lio.

---

## ğŸ¯ Objetivo do Projeto

Demonstrar, na prÃ¡tica:

* Arquitetura backend bem estruturada
* Uso de mensageria com RabbitMQ
* Processamento assÃ­ncrono de eventos
* Boas prÃ¡ticas com Spring Boot
* Testes unitÃ¡rios com Mockito
* SimulaÃ§Ã£o realista de um fluxo de pagamentos

ğŸš€ **Projeto ideal para estudo, portfÃ³lio e avaliaÃ§Ã£o de nÃ­vel backend Java.**

---

## ğŸ—ï¸ Tecnologias Utilizadas

### Backend

* Java 17
* Spring Boot
* Spring Web
* Spring Data JPA
* Hibernate

### Banco de Dados

* PostgreSQL
* Flyway Migrations

### Mensageria

* RabbitMQ

### Testes

* JUnit
* Mockito

### Outros

* MapStruct (mapeamento DTO)
* Lombok
* Docker
* Git & GitHub

---

## ğŸ“Œ DescriÃ§Ã£o do Projeto

O **PayFlow** Ã© um sistema de gestÃ£o de assinaturas e faturamento que permite:

* Cadastro de usuÃ¡rios e planos de assinatura
* CriaÃ§Ã£o de assinaturas vinculadas a usuÃ¡rios e planos
* GeraÃ§Ã£o automÃ¡tica de faturas (**Billing**) associadas Ã s assinaturas
* SimulaÃ§Ã£o de pagamentos via endpoint REST
* ValidaÃ§Ã£o de pagamentos atravÃ©s de **webhook**
* Processamento assÃ­ncrono de eventos com **RabbitMQ**
* AtualizaÃ§Ã£o automÃ¡tica do status das faturas
* Testes unitÃ¡rios cobrindo cenÃ¡rios de sucesso e falha no pagamento

---

## âš¡ Funcionalidades Principais

### 1ï¸âƒ£ Assinaturas

* Um usuÃ¡rio pode possuir um ou mais planos
* Cada plano gera faturas periÃ³dicas

### 2ï¸âƒ£ Faturas (Billing)

Cada fatura possui:

* Valor
* Data de vencimento
* Status:

  * `PENDING`
  * `PAID`
  * `FAILED`
  * `OVERDUE`

Pagamento via endpoint:

```
POST /billing/{billingId}/pay
```

---

### 3ï¸âƒ£ Pagamento Simulado

Ao criar um pagamento:

* Ã‰ gerado um **paymentUrl fake**
* Ã‰ criada uma **transactionId Ãºnica**
* O status inicial da fatura permanece como `PENDING`

Exemplo de resposta:

```json
{
  "billingId": 1,
  "paymentUrl": "https://fake-gateway/pay/tx_123",
  "transactionId": "tx_123",
  "billingStatus": "PENDING"
}
```

---

### 4ï¸âƒ£ Webhook de Pagamento

Simula a confirmaÃ§Ã£o do gateway de pagamento:

```json
{
  "billingId": 1,
  "event": "payment_approved",
  "transactionId": "tx_123"
}
```

Eventos possÃ­veis:

* `payment_approved`
* `payment_failed`

AÃ§Ãµes realizadas:

* Atualiza o status da fatura para `PAID` ou `FAILED`
* Registra a data do pagamento

---

### 5ï¸âƒ£ Processamento AssÃ­ncrono

* Eventos de pagamento sÃ£o enviados para o **RabbitMQ**
* O consumidor processa os eventos de forma assÃ­ncrona
* Simula um fluxo real de integraÃ§Ã£o com gateways externos

---

## ğŸ› ï¸ Estrutura do Projeto

```
com.payflow.app
â”œâ”€â”€ application
â”‚   â”œâ”€â”€ controller        # Controllers REST
â”‚   â”œâ”€â”€ dto               # DTOs de request e response
â”‚   â””â”€â”€ mapper            # MapStruct mappers
â”‚
â”œâ”€â”€ domain
â”‚   â”œâ”€â”€ entities          # Entidades JPA
â”‚   â”œâ”€â”€ enums             # EnumeraÃ§Ãµes (BillingStatus)
â”‚   â””â”€â”€ service           # Regras de negÃ³cio
â”‚
â”œâ”€â”€ infrastructure
â”‚   â””â”€â”€ repository        # RepositÃ³rios JPA
â”‚
â””â”€â”€ tests
    â””â”€â”€ service           # Testes unitÃ¡rios com Mockito
```

---

## ğŸ”— Endpoints Principais

| MÃ©todo | Endpoint                 | DescriÃ§Ã£o                                    |
| ------ | ------------------------ | -------------------------------------------- |
| GET    | /billing                 | Lista todas as faturas (opcional por userId) |
| GET    | /billing/{billingId}     | Consulta uma fatura pelo ID                  |
| POST   | /billing/{billingId}/pay | Cria pagamento simulado                      |
| POST   | /webhook                 | Recebe evento de pagamento                   |

---

## ğŸ§ª Testes UnitÃ¡rios

Testes escritos com **JUnit** e **Mockito**, simulando dependÃªncias como repositÃ³rios e mensageria.

### CenÃ¡rios testados

* Pagamento aprovado â†’ fatura marcada como `PAID`
* Pagamento falho â†’ fatura marcada como `FAILED`

### Exemplo de Teste

```java
@Test
void should_mark_billing_as_failed_when_payment_fails() {
    when(billingRepository.findById(1L)).thenReturn(Optional.of(billing));

    WebhookPaymentRequest request =
        new WebhookPaymentRequest(1L, "payment_failed", "tx_123");

    billingService.processWebhook(request);

    assertEquals(BillingStatus.FAILED, billing.getStatus());
    verify(billingRepository).save(billing);
}
```

---

## ğŸ’» Como Rodar o Projeto (Docker)

Este projeto jÃ¡ estÃ¡ **totalmente configurado para execuÃ§Ã£o via Docker**, nÃ£o sendo necessÃ¡rio instalar Java, Maven, PostgreSQL ou RabbitMQ localmente.

---

### 1ï¸âƒ£ PrÃ©-requisitos

* Docker
* Docker Compose

---

### 2ï¸âƒ£ Clonar o repositÃ³rio

```bash
git clone https://github.com/seu-usuario/payflow.git
cd payflow
```

---

### 3ï¸âƒ£ Subir a aplicaÃ§Ã£o com Docker

Na raiz do projeto, execute:

```bash
docker compose up --build
```

Ou em segundo plano:

```bash
docker compose up -d --build
```

Este comando irÃ¡ subir automaticamente:

* AplicaÃ§Ã£o Spring Boot
* PostgreSQL
* RabbitMQ

---

### 4ï¸âƒ£ Acessos

* **API:** [http://localhost:8080](http://localhost:8080)
* **RabbitMQ Management:** [http://localhost:15672](http://localhost:15672)

  * usuÃ¡rio: `guest`
  * senha: `guest`
* **PostgreSQL:** localhost:5432

---

### 5ï¸âƒ£ Testar os Endpoints

* Postman
* Insomnia
* Thunder Client

---

### â„¹ï¸ ObservaÃ§Ãµes

* As **migrations do Flyway** sÃ£o executadas automaticamente ao subir o container
* Banco de dados e filas sÃ£o inicializados via Docker Compose
* Ideal para execuÃ§Ã£o local, testes tÃ©cnicos e demonstraÃ§Ã£o de projeto
