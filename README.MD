PayFlow

Sistema de gerenciamento de assinaturas, faturamento e pagamentos simulados, construÃ­do em Java Spring Boot com integraÃ§Ã£o de filas assÃ­ncronas via RabbitMQ.

ğŸ— Tecnologias utilizadas

Backend: Java 23, Spring Boot 4

Banco de dados: PostgreSQL

ORM: Spring Data JPA / Hibernate

Mensageria: RabbitMQ

Testes unitÃ¡rios: JUnit 6, Mockito

Mapeamento DTO: MapStruct

Controle de versÃ£o: Git + GitHub

ğŸ“Œ DescriÃ§Ã£o do projeto

O PayFlow Ã© um sistema de gestÃ£o de assinaturas e faturamento que permite:

Cadastro de usuÃ¡rios e planos de assinatura.

CriaÃ§Ã£o de assinaturas vinculadas a usuÃ¡rios e planos.

GeraÃ§Ã£o automÃ¡tica de faturas (Billing) associadas Ã s assinaturas.

SimulaÃ§Ã£o de pagamentos via endpoint /billing/{id}/pay.

ValidaÃ§Ã£o de pagamentos atravÃ©s de webhook.

Processamento assÃ­ncrono de eventos via RabbitMQ.

MudanÃ§a automÃ¡tica do status da fatura (PENDING, PAID, FAILED) de acordo com o evento de pagamento.

Testes unitÃ¡rios simulando cenÃ¡rios de pagamento aprovado e falho.

âš¡ Funcionalidades principais
1. Assinaturas

Um usuÃ¡rio pode ter um ou mais planos.

Cada plano gera faturas periÃ³dicas (Billing).

2. Faturas (Billing)

Status: PENDING, PAID, FAILED, OVERDUE.

Possui data de vencimento e valor.

Pode ser paga via endpoint POST /billing/{billingId}/pay.

3. Pagamento simulado

Ao criar pagamento, Ã© gerado um link fake e uma transactionId Ãºnica.

Status inicial da fatura: PENDING.

Webhook simula confirmaÃ§Ã£o ou falha do pagamento:

{
"billingId": 1,
"event": "payment_approved",
"transactionId": "tx_123"
}

4. IntegraÃ§Ã£o assÃ­ncrona

RabbitMQ Ã© usado para simular eventos de pagamento.

Permite testar processamento assÃ­ncrono e webhooks de forma realista.

ğŸ›  Estrutura do projeto
com.payflow.app
â”œâ”€ application
â”‚  â”œâ”€ controller           # Controllers REST
â”‚  â”œâ”€ dto                  # DTOs de request e response
â”‚  â””â”€ mapper               # MapStruct mappers
â”œâ”€ domain
â”‚  â”œâ”€ entities             # Entidades JPA
â”‚  â”œâ”€ enums                # EnumeraÃ§Ãµes (BillingStatus)
â”‚  â””â”€ service              # LÃ³gica de negÃ³cio
â”œâ”€ infrastructure
â”‚  â””â”€ repository           # RepositÃ³rios Spring Data JPA
â””â”€ tests
â””â”€ service              # Testes unitÃ¡rios com Mockito

ğŸ”— Endpoints principais
MÃ©todo	Endpoint	DescriÃ§Ã£o
GET	/billing	Lista todas as faturas (opcional por userId)
GET	/billing/{billingId}	Consulta uma fatura pelo ID
POST	/billing/{billingId}/pay	Cria pagamento simulado (gera paymentUrl e transactionId)
POST	/webhook	Recebe evento de pagamento (aprovado ou falho)
Exemplo de POST /billing/{billingId}/pay

Request:

{}


Response:

{
"billingId": 1,
"paymentUrl": "https://fake-gateway/pay/tx_123",
"transactionId": "tx_123",
"billingStatus": "PENDING"
}

Exemplo de Webhook

Request:

{
"billingId": 1,
"event": "payment_approved",
"transactionId": "tx_123"
}


AÃ§Ã£o:

Altera status da fatura para PAID ou FAILED de acordo com o evento.

Registra data do pagamento.

ğŸ§ª Testes

Testes unitÃ¡rios com JUnit 6 e Mockito.

CenÃ¡rios testados:

Pagamento aprovado â†’ fatura marcada como PAID.

Pagamento falho â†’ fatura marcada como FAILED.

Exemplo de teste com Mockito:

@Test
void should_mark_billing_as_failed_when_payment_fails() {
when(billingRepository.findById(1L)).thenReturn(Optional.of(billing));
WebhookPaymentRequest request = new WebhookPaymentRequest(1L, "payment_failed", "tx_123");
billingService.processWebhook(request);
assertEquals(BillingStatus.FAILED, billing.getStatus());
verify(billingRepository).save(billing);
}

ğŸ’» Como rodar o projeto

Clonar repositÃ³rio:

git clone https://github.com/seu-usuario/payflow.git


Configurar PostgreSQL e criar banco payflow.

Configurar RabbitMQ local ou docker.

Ajustar application.properties com credenciais do banco e RabbitMQ.

Rodar projeto:

mvn spring-boot:run


Testar endpoints com Postman ou Insomnia.